#! /usr/bin/python
import os
import mingus.core.intervals as intervals
import mingus.core.chords as chords
#import mingus.core.scales as scales
from mingus.containers.Bar import Bar
from mingus.containers.Track import Track
import mingus.extra.LilyPond as LilyPond
from mingus.containers.Instrument import Instrument
from mingus.containers.Composition import Composition
from mingus.containers.Note import Note
from mingus.midi.MidiFileOut import write_Track

from random import shuffle
from random import choice

from itertools import repeat, chain

from compiler.ast import flatten
from collections import deque

_note_dict = { 
    'C' : 0,
    'C#': 1,
    'Db': 1,
    'D' : 2,
    'D#': 3,
    'Eb': 3,
    'E' : 4,
    'F' : 5,
    'F#': 6,
    'Gb': 6,
    'G' : 7,
    'G#': 8,
    'Ab': 8,
    'A' : 9,
    'A#': 10,
    'Bb': 10,
    'B' : 11
}
_note_sub = {
    'C' : 'C',
    'C#': 'Db',
    'Db': 'Db',
    'D' : 'D',
    'D#': 'Eb',
    'Eb': 'Eb',
    'E' : 'E',
    'F' : 'F',
    'F#': 'Gb',
    'Gb': 'Gb',
    'G' : 'G',
    'G#': 'Ab',
    'Ab': 'Ab',
    'A' : 'A',
    'A#': 'Bb',
    'Bb': 'B',
    'B' : 'B',
    'Dbb': 'C',
    'Bbb': 'A',
    'R':'R',
}
def longest_duplicate_substring(string):
    l = list(string)
    d = deque(string[1:])
    match = []
    longest_match = []
    while d:
        for i, item in enumerate(d):
            if l[i]==item:
                match.append(item)
            else:
                if len(longest_match) < len(match):
                    longest_match = match
                match = []
        d.popleft()
    return longest_match

def interval(notes):
    note1, note2 = notes
    n1,oct1 = note1
    n2,oct2 = note2
    return abs ( _note_dict[n1]+12*oct1 - _note_dict[n2]-12*oct2 )

def in_range(min_dict):
    _,notes = min_dict
    note1, note2 = notes
    n2,oct2 = note2
    if _note_dict[n2]+12*oct2 > 30:
        return True
    return False

def min_interval(note1,note2,init_octave=3):
    possible = [[[note1,init_octave],[note2,i]] for i in range(1,5)]
    min_dict = zip(map(interval,possible),possible)
    min_dict = filter(in_range, min_dict)
    return  sorted(min_dict)[0]

class walking_bass():
    '''
    Usage: 
        >>> B = walking_bass(['Bb','Eb7',['Bb','F7'],'Bb7','Eb7','Eb07',['Bb','F7'],'Bb','F7','F7','Bb','Bb'])
        >>> print B.bassline
    '''
    author = ''
    title = ''
    chord =''
    chordsd = []
    bassline = []
    i = Instrument()
    def __init__(self, chords, title = 'generated by walkingbass.py', author = 'aul Chambers'):
        self.author = author
        self.title = title
        self.chords = chords
        self.chordsd = []

        self.i.name = "Double Bass"
        self.i.clef = "bass"
        self.i.set_range((Note('C-0'), Note('F-6')))

        self.bassline = self._realbook(self.chords)
        self.bassline = flatten(self.bassline)
        longest_common = longest_duplicate_substring(self.bassline)
        print longest_common #TODO:IMPLETMENT THIS
        return
        self._naive()
        self._flow()


        self.track = self._create_track()
        self.track.add_chords(self.chords)
        
        self.to_png()
        self.to_midi()
        self.to_mp3()

                    #notes = chords.from_shorthand(chord)
    def _realbook(self, score, depth = 0): 
        bassline = []
        for chord in score:
            if type(chord) is list:
                bassline.append(self._realbook(chord,depth+1))
            else:
                bassline.append([chord+ ' x ' +str(4 - depth*2)])
        return bassline
    def _naive(self):
        naivebassline= []
        for chord in self.bassline:
            chord, _ , time = chord.split(' ')
            if chord in ['R','r']: naivebassline.append(['R']*int(time)); continue
            notes = chords.from_shorthand(chord)
            accessory_notes = notes[1:]
            shuffle(accessory_notes)
            naivebassline.append([notes[0]]+accessory_notes[:(int(time)-1)])
        self.bassline = flatten(naivebassline)
        self.bassline = map(lambda x:_note_sub[x],self.bassline)
    def _flow(self):
        self.octave = []
        if ord(self.bassline[0][0]) < ord('E'): init_octave = 3
        else: init_octave = 2
        self.octave.append (init_octave)
        for note1,note2 in zip(*[self.bassline[i:] for i in range(2)]):
            if note1 not in ['r','R'] and note2 not in ['r','R']:
                interval, notes = min_interval( note1, note2 ,init_octave )
                init_octave =  notes[1][1]
                #print interval,notes
            self.octave.append(init_octave)

    def _create_track(self):
        tp = Track(self.i)
        b = Bar( (4,4) )
        for (i, note) in enumerate( self.bassline ):
            if note in ['r','R']:
                tp.add_notes(None,4)
                continue
            tp + (note+'-'+ str(self.octave[i]))
        return tp
    def to_png(self):
        c = Composition()
        c.set_author(self.author)
        c.set_title(self.title)
        c.add_track(self.track)
        ly_string = LilyPond.from_Composition(c)
        #print ly_string
        LilyPond.to_png(ly_string, self.title)
    def to_midi(self,bpm=200):
        write_Track(self.title+'.mid',self.track,bpm=bpm)     
    def to_mp3(self):
        os.system('rm '+self.title+'.mp3')
        os.system('timidity '+self.title+'.mid'+' -Ow -o - | ffmpeg -i - -acodec libmp3lame -ab 64k '+self.title+'.mp3')

                # TODO: memory of pattern
                # triplets and bells and whistles
                # add scales

        
#TODO: up down the staff C-1 or C-2  ??



if __name__ == '__main__':
    B = walking_bass([
        ['Bb7','G7'],['Cm7','F7'],['Dm7','G7'],['Cm7','F7'],
        ['Fm7','Bb7'],['Eb7','Ab7'], ['Dm7','G7'],['Cm7','F7'],
        ['Bb7','G7'],['Cm7','F7'],['Dm7','G7'],['Cm7','F7'],
        ['Fm7','Bb7'],['Eb7','Ab7'],['Cm7','F7'],'Bb6',
        'D7','R','G7','R',
        'C7','R','F7','R',
        ['Bb7','G7'],['Cm7','F7'],['Dm7','G7'],['Cm7','F7'],
        ['Fm7','Bb7'],['Eb7','Ab7'],['Cm7','F7'],'Bb6'
        ],'Oleo')

    # B = walking_bass(['Bb','Eb7',['Bb','F7'],'Bb7','Eb7','Eb07',['Bb','F7'],'Bb','F7','F7','Bb','Bb'],'Blue Monk') # Blue Monk - Thelonious Monk
    # B = walking_bass(['C','Bb'],'Tester')
